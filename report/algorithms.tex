\subsection{Used}

\subsubsection{Trial division}

Trial division is one of the most inefficient algorithms for factorization of large integers. It is however one of the most efficient algorithms for factoring small integers and it also the easiest algorithm to perceive.
The trial division algorithm only have a few steps. It begins with finding a set of prime-numbers using some algorithm such as the sieve of eratosthenes then iteratively check if \(N\) divided by any of these primes grants no remainder. If it does not grant any remainder the prime used in the division is a factor. The algorithm will continue checking this until \(N\) becomes one.
A simple optimization of trial division is to never check primes greater than the square root of \(N\). Considering that if \(N = a * b\) and if a is greater than \(\sqrt{N}\) then \(b\) must be smaller than \(\sqrt{N}\). So for every factor greater than \(\sqrt{N}\) there has to be one factor smaller than \(\sqrt{N}\) thus if we check for factors up to \(\sqrt{N}\) we will find a factor unless \(N\) is already prime.


\paragraph{Pseudocode:}

\textcolor{white}{ }

\begin{algorithm}
\caption{Trial division}
\begin{algorithmic}
\Function {trail\_division}{$N$}
	\If{$N = 1$}
	 	\State \Return
	\EndIf
	\State $list\_of\_primes = sieve\_of\_eratosthenes(\sqrt{N})$
	\State prime\_factors = $\{\}$
	\ForAll{$prime$ in $primes$} 
		\While{ $n \bmod prime = 0$}
			\State $prime\_factors.add(prime)$
			\State $n = n / p$
		\EndWhile
	\EndFor
	\If {$n$ not equal to $1$}
		\State \Return $prime\_factors.add(n)$
	\EndIf
	\State \Return $prime\_factors$
	\EndFunction
	\end{algorithmic}
\end{algorithm}


\subsubsection{Pollard’s rho}

Pollard’s rho is a factorization algorithm invented by John Pollard. It is also known as Pollard’s Monte Carlo factorization algorithm due to it random properties and does not always manage to return a result. However, when it does return a result it always return a correct one.
The main idea of Pollard’s rho is that if you pick a random number \(x\), then pick another random number y where both are between zero and N, you can check whether \((x-y)\) and \(N\) has a GCD which is not equal to one. If it does it is all fine but if it does not, you would have to find another random number \(z\) and check whether \((z-x)\) or \((z-y)\) has a GCD with \(N\) that is not equal to one. If it still does not grant a GCD which is not equal to one you will have to keep introducing random numbers and check if they work.
As GCD is a very expensive operation picking numbers completely random may not be profitable. Therefore a typical choice for picking the numbers is using the formula \(x^2 + a\) where \(a\) is a constant. This a can be chosen at will and certain \(a\)’s are better than others for specific \(N\)’s.
Important to notice is that \(N\) can obviously not have any factors greater than itself thus the algorithm should be run in modulo \(N\) number space to repeat the process incase we reach numbers greater than \(N\). 
The algorithm will appear as cycling to the answers and whenever a cycle has been detected the algorithm will have found a solution. Note that a solution can in some cases include \(N\) even if \(N\) is not a prime. This is a result that the algorithm failed to find a factor. Pollard’s rho uses Floyd’s cycle finding algorithm to discover these cycles.

\paragraph{Floyd’s cycle finding algorithm}

Floyd’s cycle finding algorithm is used to find cycles of calls in a program in order to prevent the program from running infinitely. Consider a small program that make a sequence of function calls such as this one

\begin{algorithm}
%\caption{Trial division}
	\begin{algorithmic}
		\State $x = 1$
		\While {$x \neq  5$}
			\State $x = f(x)$
		\EndWhile	
	\end{algorithmic}
\end{algorithm}

If the function \(f\) in this program would return numbers such as the sequence

\[f(1) = 2\] 
\[f(2) = 3\] 
\[f(3) = 1\]

it would result in an endless loop where the program keep running in cycles. The solution to this is to use two pointers which move at different speeds. This is commonly referred as a tortoise and hare algorithm. 
As two pointers move at different speeds, one will move much further ahead than the other at a certain time. However, if there is a cycle both of them will sooner or later get stuck in it and therefore you could easily check if a cycle exists by checking if the two pointers is located at the same spot.

\paragraph{Pseudocode:}

\textcolor{white}{ }

\begin{algorithm}
\caption{Pollard rho}
\begin{algorithmic}
\Function {pollard}{$N$}
	\If{$N$ mod $2 = 0$}
	 	\State \Return $2$
	\EndIf
	\State $x = random()$
	\State $c = random()$
	\State $y = c$
	\State $g = 1$
	\While{$g = 1$} 
		\State $x = f(x)$
		\State $y = f(f(y)$
		\State $g = gcd(x-y,N)$
	\EndWhile
	\If {$g = N$}
		\State \Return $error$
	\EndIf
	\State \Return $g$
\EndFunction
\Function{f}{$N$}
	\State \Return $(N*N + c) \% N$
\EndFunction{}
\end{algorithmic}
\end{algorithm}



\subsection{Considered}