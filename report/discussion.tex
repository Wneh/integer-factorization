Before we actually sat down and started to program we did research on the algorithms and deciding which ones we we’re going to implement. We agreed on starting with the basic Pollard rho and thereafter continue improving it by rewriting it to Pollard Brent.

During our research we clearly understood that the algorithm that gave the best result was the quadratic sieve. We tried to find any good paper on how to implement the algorithm but we found mostly mathematical papers with fuzzy instructions. Hence we decided not to try to implement in and rather try to implement a good Pollard Brend and try to optimize it instead.

At the end we noticed that the algorithms gave good result on different type on N. Thus for the final version we combined all the algorithms we had implemented and spend a great deal of time to find breaking points for each algorithm though it resulted in an even better score.

In the beginning of the project we planned on having charts on how well the algorithms performed with different iteration numbers. Thus during the project we noticed that the result for the same number of iterations could vary quite much. Therefore we decided not compare the result depending on the number of iterations.

\subsection{Implementation details}

\subsubsection{Trial division}

Trial division were used in both Pollard’s rho and Pollard Brent algorithms for optimization purpose. From the beginning we made a list of small prime numbers to try out before running other algorithms. We decided that the twenty to forty first prime numbers would be enough to ensure that the majority of non-prime $N$’s should get at least one factor from this without making it too costly.

\subsubsection{Pollard’s rho}

For Pollard’s rho we implemented it directly from its pseudo code and it work straight away. We did try alter parameters such as constants, skipping the larger numbers and setting a limit for the iteration to make sure we do not spend too much time on a specific number. No other optimizations were done. 

\subsubsection{Pollard Brent}

Pollard Brent is where most our work was done. It was also the first algorithm to be implemented as it were not too hard to write and were supposively superior to Pollard’s rho. However we did have several setbacks with it.

On the first implementation we felt that it were not working very well. At least our institution were that something must be wrong. We did not follow the algorithm exactly at this point but followed some strange posts from the internet about how to make it more efficient such as using primes for constants and change these after a few iterations. It proved to be incorrect thus making us move on to a second version.

The second implementation was more closely based on what Pollard Brent really is. Removing the so called “optimizations” we read about such as using primes for constants and changing these over time. Instead we set them to one and also reduced the number of checks of how long time the program has been running. This in all did not grant much of a performance increase but changing the value $m$ (used to count iterations before GCD) to the numbers bit length resulted in a much greater performance increase. At this time we also had a strange idea about changing the initial random value.

Using the fact that any non prime number should have a factor that is less than or equal to its square root we decided to try out changing the random from giving a number up to $N$ to a number up to $\sqrt{N}$ for our starting-point in hope that we would end up finding this factor faster. This also granted us a quite big performance increase though we were unsure about if it really does work.

\subsubsection{Pollard’s P-1}

We never expected to implement Pollard’s P-1 but near the end of the project we felt that it would be nice to try it. Especially as we had worked quite a lot on John Pollard’s algorithms it would be nice to add one more of his.
The implementation of Pollard’s P-1 was very smooth and the only problem we had was that the wikipedia page stated we needed a logarithm function of base q where q is a prime. After reading more we noticed that it is enough to use a prime instead of this logarithm and it begun working. Still it were not performing as good as Pollard’s rho or Pollard Brent but was very fast to find a factor from time to time. This made us go with the idea of combining it with the previous Pollard Brent incase it did not produce an answer in time. At the same time we made Pollard’s rho run incase Pollard’s P-1 failed to grant some extra chances of finding a solution.